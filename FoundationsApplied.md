# Foundations AppliedThere is a lot of discussion in programming about developing in a modular way. Solve problems in a reusable way so that if your solution ever needs adjusted all possible places it was being implemented will be updated with a single change.Let's take a moment to examine an oversimplified problem that can commonly occur.## The ProblemLet's discuss the bad practice of having too much inconsequential or any debugging information in your console log and too many console.logs through your codebase.``` javascript// Consider we have hundreds of items in the cartconst aryShoppingCart = [  { productID: 'f4dacfd1-5ad1-45f4-9322-d4dc791c6ea7', qty: 100},  { productID: 'aa5094e5-5461-43a1-a1fb-c256f3dfb5e2', qty: 3},  { productID: 'faedb471-ca0e-48a9-84bf-26fe49d23e4f', qty: 14},] // We loop through the cart itemsfor (let cartIndex = 0;   		 cartIndex < aryShoppingCart.length; 		 cartIndex++){    // Singular Item in Cart    let itemInLoop = aryShoppingCart[cartIndex];      // TEMP: Log for debugging some problem    console.log(itemInLoop.productID);  }```Consider putting a console.log inside of a loop to test the output of some changing variable. This can pollute the output so that it's exceedingly difficult to derive meaningful information from the console. On top you getting lost in the heap of console.logs, consider other developers would be lost in the deluge of console.logs scrolling across the screen. So, If you need to temporarily test the contents of this loop do you put the console.log there only when you need it? Maybe.### The Problem ExplainedIn this overly simple example it's hard to talk in terms of complex problems, but imagine that this scenario was more complex.  Let's say you were trying to diagnose 50 loops across 12 files, making certain that each's output is operating as expected.So, let's reexamine the question, do you put the console.log there only when you need it?No, hard no. The amount of effort to go through all your code to add a simple console.log into all of these places for a temporary test of your code would require a consequential amount of effort and time.Additionally, if this is a temporary test the thought is that you will just be deleting all of these console.logs when you have concluded testing, but what if this test may need to be performed again in the future… Do you again waste the effort to add all of them into the various files a second, third or fifteenth time?If a temporary console.log is not going to work, and a permanent console.log would disrupt other developers with an avalanche of output how do we solve this problem?## Solution: Attempt One (Conditional)Remember that as programmers we are really just problem solvers, not so much code monkeys turning wrenches. We need to think through the impact of our possible solutions and how they may positively or negatively impact everyone from the user to other developers on the project currently, or any developer that could join the project.In this situation, I would propose that we create a hybrid solution of temporary and permanent, meaning we create a mechanism that we can turn on or off that will enable or disable the console logs within this loop.``` javascriptconst showConsoleLogs = true;// We loop through the cart itemsfor (let cartIndex = 0;   		 cartIndex < aryShoppingCart.length; 		 cartIndex++){    // Singular Item in Cart    let itemInLoop = aryShoppingCart[cartIndex]  	if(showConsoleLogs){		console.log(itemInLoop.productID);  	}}```How does this address the problems we have defined? > Will other devs have their output polluted by many console logs? Maybe. That depends on if we committed our code to git with the showConsoleLogs = true or not. So, in this scenario we would need to ensure that we properly set this variable to false once we are done. That sounds like a problem just waiting to happen.> Will this solution require a non-trivial amount of time to enable / disable?If we have 50 places across 12 files, yes this will still require a large amount of effort to turn on/off. > Any new problems that could arise?That is a lot of files to open, edit, save and close. Lots of room for human error. Hopefully we remember to get them all each time and never mess up otherwise it's going to be a pain to track down the one file or section that has it wrong.Additionally, what happens in 6 months after we haven't been working with this code actively, will we even remember the 50 locations this change needs to be made? That in itself seems like a problem we should try and address after this first issue.## Solution: Attempt Two (Env)The idea of having to have each developer juggle ```showConsoleLogs'``` value to turn the logging on or off seems a lot like the issue discussed regarding passwords being in the codebase from the standpoint that each developer will need to juggle their own password in the codebase and you're constantly going to have conflicts as that is changed.The solution to the password problem discussed was Environmental Variables (env) and again that solution seems that it could fit.Rather than having the toggle attached to a variable set multiple times in multiple files an environmental available seems that it will fit the need. Let's investigate what that would look like.``` javascript// We loop through the cart itemsfor (let cartIndex = 0;   		 cartIndex < aryShoppingCart.length; 		 cartIndex++){    // Singular Item in Cart    let itemInLoop = aryShoppingCart[cartIndex]  	if(process.env.SHOW_CONSOLE_LOGS){		console.log(itemInLoop.productID);  	}}```Then to activate that we would set SHOW_CONSOLE_LOGS = true when we start the node file.```SHOW_CONSOLE_LOGS=true node path/to/file.js```Let's run through our questions once more and see how this attempt stacks up> Will other devs have their output polluted by many console logs? No, they will need to explicitly opt into seeing these logs with the environmental variable. If this option is selected we should really document exactly how to turn them on otherwise no one will know about what was built.
> Will this solution require a non-trivial amount of time to enable / disable?No significant amount of time would be needed to enable / disable.> Newly Identified: Potentials for human error?This solves the issue we identified in the last solution. If we bake the conditional if(process.env. SHOW_CONSOLE_LOGS) into each place we only need to ensure that they are there one time, and then never again. So, we were able to solve this without really trying, perfect!> Any new problems that could arise?Maybe. You see, this solution creates the environmental variable SHOW_CONSOLE_LOGS. It is narrowly focused in that this specific environmental variable is going to be used exclusively for this one problem. Assume we develop a moderately sized project, there could be several situations similar to this where we apply this same solution. At the end of that, this code is rather repetitive if it will be across 50 instances and doesn't even address the secondary problem that we first set out to solve, too many console.logs through our codebase.### Don't Duplicate Code / EffortOne of the major tenants of development is making reusable code. We have defined a situation where you will have 50 occurrences of an if statement with a console.log within it. If we were to change the environmental variable from SHOW_CONSOLE_LOGS to something more descriptive like ACTIVATE_DEBUG_INFO_ON_LOOPED_CONSOLE_LOGS we are going to have 50 places to make this change.Additionally, this bit of functionality can be reused in a variety of ways beyond just this looped console.log situation. Looking at its functionality, we are building a tool to display debug information, only when we want it. So if we are going to be good devs we might explore building a reusable solution that fits our current needs and can be easily refactored in the future for future needs.## Solution: Attempt 3 (Modules)Let’s kick this attempt off by moving away from the SHOW_CONSOLE_LOGS env and be more flexible by saying that we are going to have a DEBUG_MODE that we will enable / disable via environmental variable.``` javascript// tool.js// .debug is the method exportedexports.debug = function(output){		// If the DEBUG_MODE env is set	if(process.env.DEBUG_MODE){			// The only console.log in our codebase		console.log(output)	}}`````` javascript//  main.js// import the target file as 'myTool'const myTool = require('/path/to/tool.js');// We loop through the cart itemsfor (let cartIndex = 0; 		cartIndex < aryShoppingCart.length; 		cartIndex++){	// Singular Item in Cart	let itemInLoop = aryShoppingCart[cartIndex]    	// Send info to the Debug Tool to determine when to show	myTool.debug(itemInLoop.productID);}```Run the application:``` shellDEBUG_MODE=true node /path/to/main.js```Regarding the previous questions, we have been asking about our solutions this fits the bill perfectly, so far. Looking back at our initial question regarding too much debugging information, though, I can see that if we are using this all over the place we could end up seeing some problems. Consider our 50 loops this will be in use. What options do we have to identify what loop is logging what information?## Solution: FinalI would suggest we create some sort of title that we can pass to the .debug() in addition to the value we are passing through. Beyond that, we might also consider having finer grained control of what gets debugged when. Our other dev’s would still have their original problem by being overloaded by all of our console.logs once they turn on DEBUG_MODE to view their own debugged messages.Here is another situation where we need to explore how to solve this problem creatively as there is no right way to solve it.I would propose we create a numeric system that represents how fine grained we want to debug with, that way we can define on each time we are debugging.As this is the final solution that I have developed I will document it's use and examples.``` javascript// tool.js// .debug is the method exportedexports.debug = function(title, output, level){		// If the DEBUG_MODE env is set.	// If not set when we parseInt() unexpected results 	// would occur.	if(process.env.DEBUG_MODE){				// Is the DEBUG_MODE threshold hit?		// Environmental Variables come in as strings		// so if you want to eval them as an int		// you need to parseInt()		if(level <= parseInt(process.env.DEBUG_MODE)) {			// Combine the title and output together in a .log			console.log(title, output)		}	}}`````` javascript//  main.js// import the target file as 'myTool'const myTool = require('/path/to/tool.js');// We loop through the cart itemsfor (let cartIndex = 0; 		cartIndex < aryShoppingCart.length; 		cartIndex++){	// Singular Item in Cart	let itemInLoop = aryShoppingCart[cartIndex]    	// Send info to the Debug Tool to determine when to show.  	// For more info consult Debug Tool Documentation	myTool.debug("Cart Item ProductID", itemInLoop.productID, 3);}`````` markdown# Debug Tool Documentation## Example of UsageInstead of console.log() require the tool.js file and call the .debug() method passing in three arguments (title, output, level)[code] to call a debug()[code] to activate debug_mode### title: StringShould be a string that will prefix the output argument in the resulting console.log()### output: ObjectAny object that will be suffixed onto the title argument in the resulting console.log()### level: IntegerA number that indicates how fine grained the output of this particular output should be. Reference the **Debug Level Chart**## Debug Level Chart0. Production Environment Level Output1. Staging Environment Level Output2. General Debug Information for Development3. Very Detailed and in-depth Output.```Run the application:``` shellDEBUG_MODE=3 node /path/to/main.js```